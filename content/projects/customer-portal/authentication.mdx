---
title: Authentication
description: How authentication is managed in the API.
---

## Description
We have several endpoints that are protected and require an authenticated users to access the data.

<img src="https://jwt.io/img/pic_logo.svg" /><br/>
### What is JWT?
JWT stands for JSON Web Token, and it is a compact, self-contained method for securely transmitting information between parties as a JSON object. It is commonly used for authentication and data exchange in web development.

JWTs are composed of three parts: a header, a payload, and a signature. The header typically consists of the token type and the hashing algorithm used to secure the token. The payload contains the claims or information that is being transmitted. These claims can include information about the user or any other data that needs to be transmitted. The signature is generated by combining the encoded header, the encoded payload, and a secret key, which ensures the authenticity of the token and allows the recipient to verify its integrity.

JWTs are often used in authentication and authorization processes. When a user logs in, a server can generate a JWT that includes information about the user. This JWT can then be sent back to the client, and the client can include it in subsequent requests to access protected resources or routes. The server can verify the JWT to ensure the authenticity and integrity of the information it contains.

JWTs are popular because they are compact, can be easily transmitted, and can be used across different platforms and languages. They provide a way to securely transmit information without the need for additional server storage, making them a preferred method for stateless authentication in web applications.

### How we are using JWT

#### Creating token

When a user/customer signs in through the customer portal they will hit the login endpoint `/api/user/login`, as long as they provide a valid email and password we will log them in providing an access token. This token will be JWT and is created via the `generateToken()` function.

```js
const generateToken = id => {
    return jwt.sign({ id }, process.env.JWT_SECRET, {
        expiresIn: "7d"
    })
}
```
This will `sign` the token to their Portal User Id, which we use to identify the user making the request.

#### Checking the Token

In order to protect certain endpoints, such as `Get User` we will require the user to pass the protect function first.

```js
const protect = async (req, res, next) => {
    let token

    if(req.headers.authorization && req.headers.authorization.startsWith('Bearer')) {
        try {
            token = req.headers.authorization.split(" ")[1]

            // Check if token has not expired
            const checkResult = checkTokenExpiry(token);
            if (!checkResult.valid) {
                return res.status(401).json({ error: checkResult.message });
            }

            // Fetch user record from Dynamics
            const { access_token } = await GetDynamicsToken()
            req.user = await GetSingleUser(access_token, checkResult.decoded.id)
            next()
        } catch (error) {
            console.log(error)
            res.status(401).json({ error: 'Not Authorised - Token Failed'})
        }
    }

    if(!token) {
        res.status(401).json({ error: 'Please provide a token' })
    }
}
```

```js
const checkTokenExpiry = token => {
    try {
        const decoded = jwt.verify(token, process.env.JWT_SECRET);
        return { valid: true, decoded };
    } catch (err) {
        if (err.name === 'TokenExpiredError') {
            return { valid: false, message: 'Token has expired' };
        } else {
            return { valid: false, message: 'Invalid token' };
        }
    }
}
```

This will ensure that:
- There is a token present
- The token has not expired
- We match a user with the user id in the token

#### What happens next?

If the user passes this check we will pass them onto the endpoint allowing them to retrieve the data. If they do not pass this, then we will throw an error in the respsonse. 

If the token has expired we sign the user out - requiring them to login for a new token before continuing.
